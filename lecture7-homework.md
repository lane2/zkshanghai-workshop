# 第7课 课后作业
和第六课是一样的
## 第1题 xxxxxx

解答：
修改 Fibonacci 程序，使其成为宽度为3的AIR的具体操作如下：

将 Fibonacci 程序中的两个变量 f 和 g 替换为三个变量 f、g 和 h。
将初始状态 (f0, g0) 替换为 (f0, g0, 1)。
在第 i 步中，计算 f[i] 和 g[i] 的方式保持不变，但是我们还需要计算 h[i]。h[i] 可以通过以下公式计算：h[i] = g[i-1] - f[i-2]。
在第 i 步中，我们还需要计算 f[i+1]、g[i+1] 和 h[i+1]。它们可以通过以下公式计算：
f[i+1] = g[i] + h[i]
g[i+1] = f[i+1] + g[i]
h[i+1] = g[i] - f[i]
输出结果为 f[n]。
这个程序的正确性可以通过数学归纳法证明。初始状态 (f0, g0, 1) 显然满足要求。现在假设对于所有的 i，(fi, gi, hi) 都满足 Fibonacci 数列的定义，我们需要证明 (fi+1, gi+1, hi+1) 也满足 Fibonacci 数列的定义。

通过替换原来的变量 f 和 g，我们可以将 Fibonacci 数列的定义表示为 f[i] = g[i-1] 和 g[i] = f[i] + g[i-1]。利用这些等式和上面的公式，我们可以得到：

f[i+1] = g[i] + h[i] = f[i] + g[i-1] + (g[i-1] - f[i-2]) = g[i-1] + 2*g[i-2] = f[i] + g[i-1] + g[i-2]
g[i+1] = f[i+1] + g[i] = (g[i-1] + 2g[i-2]) + (f[i] + g[i-1]) = g[i-1] + 2g[i-2] + f[i] + g[i-1] = f[i+1] + 2*g[i-1]
h[i+1] = g[i] - f[i] = (f[i] + g[i-1]) - g[i-1] = f[i] - f[i-1]
因此，(fi+1, gi+1, hi+1) 也满足 Fibonacci 数列的定义，证毕。

由于这个程序可以表示为宽度为 3 的 AIR，因此可以使用 AIR 的技术来加速计算 Fibonacci 数列。

## 第二题
你能写一个仅在行i=1上应用RAP的多重集合相等性检查的约束吗？（提示：当i=1时L1(X)=1，否则为0; 因此只需要在行i=1上强制执行一个形如L1(X)*f(X) 的约束。）

解答：
具体如下：

设 X = {x1, x2, ..., xn} 和 Y = {y1, y2, ..., ym} 是两个大小为 n 和 m 的多重集合，我们要检查它们是否相等。我们可以定义一个布尔变量 b 和一个多项式 f(X, Y)，其中 f(X, Y) 是一个关于 X 和 Y 的多项式，其系数为 0 或 1。然后，我们可以在行 i=1 上强制执行以下约束：

L1(X) * f(X, Y) = L1(Y) * b

其中，L1(X) 和 L1(Y) 分别是 X 和 Y 的首项系数，L1(X) = 1，L1(Y) = 1。这个约束的含义是，如果 X 和 Y 相等，那么 f(X, Y) 的值应该为 1，b 的值也应该为 1。否则，f(X, Y) 的值应该为 0，b 的值也应该为 0。

现在我们需要定义 f(X, Y) 的形式。我们可以将 X 和 Y 中的所有元素排序，并将它们按照相同的顺序排列，然后将它们依次配对。对于每对元素 xi 和 yj，我们可以定义一个变量 bij，并将 f(X, Y) 定义为以下布尔表达式的 AND：

f(X, Y) = (b11 = 1) AND (b12 = 1) AND ... AND (bnm = 1)

其中，b11, b12, ..., bnm 是配对后得到的变量。每个变量都可以表示为：

bij = ((xi = yj) AND (xi 在 X 中出现的次数 = yj 在 Y 中出现的次数))

这个表达式的含义是，如果 xi 和 yj 相等并且它们在 X 和 Y 中的出现次数也相等，那么对应的变量 bij 的值为 1。否则，变量 bij 的值为 0。

这个约束的正确性可以通过以下方式证明：如果 X 和 Y 相等，那么 f(X, Y) 的值应该为 1，b 的值也应该为 1。因此，L1(X) * f(X, Y) = L1(Y) * b 成立。如果 X 和 Y 不相等，那么至少有一个配对的元素 xi 和 yj 不相等或它们在 X 和 Y 中的出现次数不同。因此，变量 bij 的值为 0。因此，f(X, Y) 的值为 0，b 的值也应该为 0。因此，L1(X) * f(X, Y) = L1(Y) * b 也成立。

因此，我们可以使用上述约束在行 i=1 上应用 RAP 来检查多重集合 X 和 Y 是否相等。
