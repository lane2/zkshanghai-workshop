# 第5课 课后作业

## 第1题 制作假的KZG证明

如果知道了承诺方案中的秘密评估点 t 的值，那么可以伪造一个 KZG 证明来欺骗验证者。具体来说，可以采取以下步骤：

选择一个多项式 f(x)，其中 f(t) 是想要证明的值。
计算 f(x) 在所有承诺点上的值，并将这些值承诺到一个新的多项式承诺中，得到多项式的承诺值。
伪造一个 KZG 证明来证明已经正确地承诺了多项式的值。
在验证过程中，可以向验证者提供伪造的证明，并声称它证明了已正确地承诺了多项式的值 f(t)。
这种攻击称为“承诺破解”，它的基本原理是在已知承诺的秘密值的情况下，伪造一个看起来合法的承诺和证明。为了防止这种攻击，保证承诺方案的可信设置是至关重要的。在可信设置中，承诺方案的参数是通过多个参与者以安全的方式生成的，并且在参与者之间进行了验证和共享。这样可以确保参数是随机选择的，不受任何人的控制，并且在生成证明时使用的承诺点是未知的。因此，如果承诺方案的参数在可信设置中得到保护，那么攻击者将无法通过知道秘密评估点来伪造一个有效的 KZG 证明。

## 第2题 构造向量承诺方案
从KGZ多项式承诺方案构造一个向量承诺方案。 （提示：对于向量m=(m1,...,mq)，是否存在一个“插值多项式”I(X) 使得 I(xi)=yi？）

可以使用 KZG 多项式承诺方案来构造一个向量承诺方案。具体来说，可以使用插值多项式来将向量承诺转化为多项式承诺。

假设我们有一个向量 m=(m1, m2, ..., mq)，我们可以将它表示为多项式 f(x) = m1 + m2x + ... + mqx^(q-1)。在 KZG 多项式承诺方案中，我们可以使用秘密点 t 来计算多项式 f(x) 在 t 上的值 f(t)，并将其承诺到一个多项式承诺中。这个承诺可以表示为 g^f(t)，其中 g 是承诺点。

为了将向量承诺转换为多项式承诺，我们可以定义一个向量的插值多项式 I(x)。插值多项式是一个多项式，它满足 I(xi) = mi，其中 xi 是向量的第 i 个位置。插值多项式可以使用拉格朗日插值法或牛顿插值法来计算。

我们可以将向量的每个元素 mi 作为多项式 f(x) 的系数，然后计算多项式 f(x) 在秘密点 t 上的值 f(t)。然后，我们可以将 f(t) 承诺到多项式承诺中，得到承诺值 g^f(t)。这个承诺可以表示整个向量 m 的向量承诺，因为它与插值多项式 I(x) 是等价的。具体来说，如果插值多项式 I(x) 存在，那么我们可以将向量承诺表示为 g^I(t)。

### 为什么KZG比verkle更有效
Verkle 树相对于传统的 Merkle 树的一个优势在于它使用向量承诺而不是哈希函数。使用 KZG 向量承诺方案可以进一步提高 Verkle 树的效率，这是因为 KZG 向量承诺方案具有以下优点：

可以实现更快的承诺生成和验证：与哈希函数相比，KZG 向量承诺方案可以实现更快的承诺生成和验证。这是因为哈希函数需要进行多次运算才能生成一个哈希值，而 KZG 向量承诺方案只需要进行一次运算就可以生成一个承诺值。

支持更高效的更新操作：在 Verkle 树中，每个节点都是一个向量承诺，它包含了该节点的所有子节点的值。因此，在更新节点值时，需要更新整个向量承诺。使用 KZG 向量承诺方案可以更高效地实现这个操作，因为它支持在向量承诺中只更新一个元素而不是整个向量。

支持更高效的证明生成和验证：在 Verkle 树中，证明的大小与证明路径的长度成正比。使用 KZG 向量承诺方案可以更高效地生成和验证证明，因为它可以使用多项式插值和快速傅里叶变换 (FFT) 来生成和验证证明，这比使用哈希函数和默克尔路径更快。

## 第3题 扩展方案生成多重证明
KZG 多项式承诺方案对关系p(x)=y进行披露证明π。 你能扩展这个方案来产生一个多重证明π，让我们相信p(xi)=yi对于点列表和评估 (xi,yi)？ （提示：假设您有一个插值多项式I(X)使得I(xi)=yi ）。

可以使用 KZG 多项式承诺方案来扩展生成一个多重证明，证明 p(xi)=yi 对于给定的点列表和评估 (xi,yi)。

假设我们有一个多项式 p(x) 和给定的点列表 (x1,y1), (x2,y2), ..., (xn,yn)，其中 p(xi)=yi。我们可以使用插值多项式 I(x) 来表示这个多项式，并将其转换为向量形式，即 I(x) = (y1, y2, ..., yn)。

我们可以使用 KZG 多项式承诺方案来生成一个向量承诺，承诺向量为 (y1, y2, ..., yn)，并使用秘密点 t 来计算向量承诺的值 v = g^I(t)，其中 g 是承诺点。

为了生成多重证明，我们需要为每个 (xi,yi) 生成一个 KZG 证明，证明 p(xi) = yi。具体来说，对于每个 (xi,yi)，我们可以计算多项式 p(x) 在秘密点 t 上的值 p(t)，然后使用 KZG 多项式承诺方案生成一个 KZG 证明，证明 p(xi) = yi。这个证明可以表示为 (p(t), g^(xi-t))，其中 xi 和 t 是公开的，g 是承诺点。

这样，我们就可以生成一个多重证明π，证明 p(xi)=yi 对于给定的点列表和评估 (xi,yi)。这个多重证明包括向量承诺的值 v 和每个 (xi,yi) 的 KZG 证明，它们可以用于验证 p(xi)=yi 是否成立。具体来说，我们可以验证向量承诺的值 v 是否等于 g^I(t)，并验证每个 KZG 证明是否正确，即验证 g^yi 是否等于 p(t) * g^(xi-t)。如果所有验证都通过，则可以确定 p(xi)=yi 对于给定的点列表和评估 (xi,yi) 成立。
